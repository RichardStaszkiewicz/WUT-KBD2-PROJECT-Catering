SET SQLBLANKLINES ON
CREATE TABLE DANIA 
(
  ID_DANIA NUMBER(3, 0) NOT NULL 
, NAZWA VARCHAR2(30 BYTE) NOT NULL 
, OPIS VARCHAR2(200 BYTE) 
, CENA NUMBER(5, 2) NOT NULL 
, DOSTEPNOSC NUMBER(3, 0) DEFAULT 0 NOT NULL 
, CONSTRAINT DANIA_PK PRIMARY KEY 
  (
    ID_DANIA 
  )
  ENABLE 
);

CREATE TABLE SL_BANKI 
(
  ID_BANKU NUMBER(3, 0) NOT NULL 
, NAZWA VARCHAR2(50 BYTE) NOT NULL 
, CONSTRAINT SL_BANKI_PK PRIMARY KEY 
  (
    ID_BANKU 
  )
  ENABLE 
) 
ORGANIZATION INDEX 
PCTTHRESHOLD 50;

CREATE TABLE SL_JEDNOSTKI 
(
  ID_JEDNOSTKI NUMBER(2, 0) NOT NULL 
, NAZWA VARCHAR2(30 BYTE) NOT NULL 
, SKROT VARCHAR2(10 BYTE) NOT NULL 
, CONSTRAINT SL_JEDNOSTKI_PK PRIMARY KEY 
  (
    ID_JEDNOSTKI 
  )
  ENABLE 
) 
ORGANIZATION INDEX 
PCTTHRESHOLD 50;

CREATE TABLE SL_KATEGORIE_PODATKOWE 
(
  ID_KATEGORII NUMBER(2, 0) NOT NULL 
, NAZWA VARCHAR2(30 BYTE) NOT NULL 
, OPODATKOWANIE NUMBER(2, 0) NOT NULL 
, CONSTRAINT SL_KATEGORIE_PK PRIMARY KEY 
  (
    ID_KATEGORII 
  )
  ENABLE 
) 
ORGANIZATION INDEX 
PCTTHRESHOLD 50;

CREATE TABLE SL_STATUSY_ZAMOWIEN 
(
  ID_STATUSU NUMBER(2, 0) NOT NULL 
, NAZWA VARCHAR2(20 BYTE) NOT NULL 
, CONSTRAINT SL_STATUSY_ZAMOWIEN_PK PRIMARY KEY 
  (
    ID_STATUSU 
  )
  ENABLE 
) 
ORGANIZATION INDEX 
PCTTHRESHOLD 50;

CREATE TABLE KONTRAHENCI 
(
  ID_KONTRAHENTA NUMBER(5, 0) NOT NULL 
, IMIE VARCHAR2(20 BYTE) 
, NAZWISKO VARCHAR2(40 BYTE) 
, NAZWA VARCHAR2(50 BYTE) 
, NIP CHAR(10 BYTE) 
, MAIL VARCHAR2(40 BYTE) NOT NULL 
, ADRES VARCHAR2(150 BYTE) NOT NULL 
, TELEFON VARCHAR2(15 BYTE) NOT NULL 
, ID_BANKU NUMBER(3, 0) 
, NR_KONTA VARCHAR2(26 BYTE) 
, CZY_FIRMA CHAR(1 BYTE) DEFAULT 0 NOT NULL 
, CONSTRAINT KONTRAHENCI_PK PRIMARY KEY 
  (
    ID_KONTRAHENTA 
  )
  ENABLE 
);

CREATE TABLE TOWARY 
(
  ID_TOWARU NUMBER(4, 0) NOT NULL 
, NAZWA VARCHAR2(40 BYTE) NOT NULL 
, ILOSC NUMBER(5, 2) DEFAULT 0 NOT NULL 
, ID_JEDNOSTKI NUMBER(2, 0) NOT NULL 
, ID_KATEGORII NUMBER(2, 0) NOT NULL 
, CONSTRAINT TOWARY_PK PRIMARY KEY 
  (
    ID_TOWARU 
  )
  ENABLE 
);

CREATE TABLE DOSTAWY 
(
  ID_DOSTAWY NUMBER(7, 0) NOT NULL 
, DATA DATE NOT NULL 
, ID_DOSTAWCY NUMBER(5, 0) NOT NULL 
, CONSTRAINT DOSTAWY_PK PRIMARY KEY 
  (
    ID_DOSTAWY 
  )
  ENABLE 
);

CREATE TABLE FAKTURY 
(
  ID_FAKTURY NUMBER(7, 0) NOT NULL 
, NR_FAKTURY VARCHAR2(20 BYTE) NOT NULL 
, ID_NABYWCY NUMBER(5, 0) NOT NULL 
, ID_SPRZEDAWCY NUMBER(5, 0) NOT NULL 
, DATA_WYSTAWIENIA DATE NOT NULL 
, DATA_ZAPLATY DATE 
, TERMIN_ZAPLATY DATE NOT NULL 
, STAWKA_VAT NUMBER(3, 0) NOT NULL 
, SPOSOB_ZAPLATY VARCHAR2(30 BYTE) 
, NETTO NUMBER(7, 2) NOT NULL 
, VAT NUMBER(7, 2) NOT NULL 
, BRUTTO NUMBER(7, 2) NOT NULL 
, WARTOSC_KWOTY_SLOWNIE VARCHAR2(100 BYTE) NOT NULL 
, CZY_WYCHODZACA CHAR(1 BYTE) AS ( CASE "ID_NABYWCY" WHEN 1 THEN '1' ELSE '0' END ) VIRTUAL 
, CONSTRAINT FAKTURY_PK PRIMARY KEY 
  (
    ID_FAKTURY 
  )
  ENABLE 
);

CREATE TABLE ZAMOWIENIA 
(
  ID_ZAMOWIENIA NUMBER(7, 0) NOT NULL 
, DATA DATE NOT NULL 
, STATUS NUMBER(2, 0) NOT NULL 
, ID_KLIENTA NUMBER(5, 0) NOT NULL 
, CONSTRAINT ZAMOWIENIA_PK PRIMARY KEY 
  (
    ID_ZAMOWIENIA 
  )
  ENABLE 
)
PARTITION BY RANGE (DATA) 
(
  PARTITION P1_91_00 VALUES LESS THAN (TO_DATE(' 2001-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) 
  TABLESPACE KBD2_1 
, PARTITION P2_01_10 VALUES LESS THAN (TO_DATE(' 2011-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) 
  TABLESPACE KBD2_2 
, PARTITION P3_11_20 VALUES LESS THAN (TO_DATE(' 2021-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) 
  TABLESPACE KBD2_3   
, PARTITION P4_21_30 VALUES LESS THAN (TO_DATE(' 2031-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) 
  TABLESPACE KBD2_4  
);

CREATE TABLE DANIA_SKLADNIKI 
(
  ID_DANIA NUMBER(3, 0) NOT NULL 
, ID_TOWARU NUMBER(4, 0) NOT NULL 
, ILOSC NUMBER(4, 2) NOT NULL 
, CONSTRAINT DANIA_SKLADNIKI_PK PRIMARY KEY 
  (
    ID_DANIA 
  , ID_TOWARU 
  )
  ENABLE 
);

CREATE TABLE DOSTAWY_POZYCJE 
(
  ID_DOSTAWY NUMBER(7, 0) NOT NULL 
, ID_TOWARU NUMBER(4, 0) NOT NULL 
, ILOSC NUMBER(5, 2) NOT NULL 
, CENA_JEDNOSTKOWA NUMBER(6, 2) NOT NULL 
, SERIA VARCHAR2(30 BYTE) 
, DATA_WAZNOSCI DATE 
, CONSTRAINT DOSTAWY_POZYCJE_PK PRIMARY KEY 
  (
    ID_DOSTAWY 
  , ID_TOWARU 
  )
  ENABLE 
);

CREATE TABLE FAKTURY_POZYCJE 
(
  ID_FAKTURY NUMBER(7, 0) NOT NULL 
, NR_POZYCJI NUMBER(4, 0) NOT NULL 
, NAZWA VARCHAR2(50 BYTE) NOT NULL 
, ILOSC NUMBER(4, 0) NOT NULL 
, ID_JEDNOSTKI NUMBER(2, 0) 
, DATA_WYKONANIA DATE 
, NETTO NUMBER(6, 2) NOT NULL 
, VAT NUMBER(2, 0) NOT NULL 
, BRUTTO NUMBER(6, 2) NOT NULL 
, CONSTRAINT FAKTURY_POZYCJE_PK PRIMARY KEY 
  (
    ID_FAKTURY 
  , NR_POZYCJI 
  )
  ENABLE 
);

CREATE TABLE ZAMOWIENIA_POZYCJE 
(
  ID_ZAMOWIENIA NUMBER(7, 0) NOT NULL 
, ID_DANIA NUMBER(3, 0) NOT NULL 
, ILOSC NUMBER(3, 0) NOT NULL 
, WARTOSC NUMBER(6, 2) NOT NULL 
, CONSTRAINT ZAMOWIENIA_POZYCJE_PK PRIMARY KEY 
  (
    ID_ZAMOWIENIA 
  , ID_DANIA 
  )
  ENABLE 
);

CREATE VIEW BILANS_ZESTAWIENIE
AS SELECT
extract(YEAR FROM f.DATA_WYSTAWIENIA) ROK,
extract(MONTH FROM f.DATA_WYSTAWIENIA) MIESIAC,
SUM(CASE WHEN f.CZY_WYCHODZACA = '0' THEN f.NETTO ELSE 0 END) SUMA_NETTO_PRZYCHODOW,
SUM(CASE WHEN f.CZY_WYCHODZACA = '1' THEN f.NETTO ELSE 0 END) SUMA_NETTO_ROZCHODOW,
SUM(CASE WHEN f.CZY_WYCHODZACA = '0' THEN f.NETTO ELSE 0 END) - SUM(CASE WHEN f.CZY_WYCHODZACA = '1' THEN f.NETTO ELSE 0 END) BILANS
FROM FAKTURY f
GROUP BY extract(YEAR FROM f.DATA_WYSTAWIENIA), extract(MONTH FROM f.DATA_WYSTAWIENIA)
ORDER BY ROK DESC, MIESIAC DESC;

CREATE VIEW DANIA_ZAMOWIENIA_ZESTAWIENIE
AS SELECT
  extract(YEAR FROM z.DATA) ROK,
  extract(MONTH FROM z.DATA) MIESIAC,
  d.NAZWA DANIE,
  COUNT(z.ID_ZAMOWIENIA) LICZBA_ZAMOWIEN
  FROM DANIA d
  JOIN ZAMOWIENIA_POZYCJE zp ON (zp.ID_DANIA = d.ID_DANIA)
  JOIN ZAMOWIENIA z ON (z.ID_ZAMOWIENIA = zp.ID_ZAMOWIENIA)
  group by extract(YEAR FROM z.DATA), extract(MONTH FROM z.DATA), d.NAZWA
  ORDER BY ROK DESC, MIESIAC DESC;

CREATE VIEW K_ZAMOWIENIA_MIESIAC
AS SELECT k.ID_KONTRAHENTA ID,
  CASE WHEN k.CZY_FIRMA = '1' THEN k.NAZWA ELSE CONCAT (k.IMIE, CONCAT(' ', k.NAZWISKO)) END NAZWA, 
  COUNT(z.ID_ZAMOWIENIA) LICZBA_ZAMOWIEN,
  SUM(f.NETTO) SUMA_NETTO
  FROM KONTRAHENCI k
  JOIN ZAMOWIENIA z ON (z.ID_KLIENTA = k.ID_KONTRAHENTA)
  JOIN FAKTURY f ON (f.ID_NABYWCY = k.ID_KONTRAHENTA)
  WHERE f.DATA_WYSTAWIENIA > sysdate-30 and z.DATA > sysdate-30 AND f.CZY_WYCHODZACA = '0'
  group by k.ID_KONTRAHENTA, CASE WHEN k.CZY_FIRMA = '1' THEN k.NAZWA ELSE CONCAT (k.IMIE, CONCAT(' ', k.NAZWISKO)) END;

CREATE VIEW K_ZAMOWIENIA_ZESTAWIENIE
AS SELECT
  extract(YEAR FROM f.DATA_WYSTAWIENIA) ROK,
  extract(MONTH FROM f.DATA_WYSTAWIENIA) MIESIAC,
  k.ID_KONTRAHENTA ID,
  CASE WHEN k.CZY_FIRMA = '1' THEN k.NAZWA ELSE CONCAT (k.IMIE, CONCAT(' ', k.NAZWISKO)) END NAZWA, 
  COUNT(z.ID_ZAMOWIENIA) LICZBA_ZAMOWIEN,
  SUM(f.NETTO) SUMA_NETTO
  FROM KONTRAHENCI k
  JOIN ZAMOWIENIA z ON (z.ID_KLIENTA = k.ID_KONTRAHENTA)
  JOIN FAKTURY f ON (f.ID_NABYWCY = k.ID_KONTRAHENTA)
  WHERE f.CZY_WYCHODZACA = '0'
  GROUP BY extract(YEAR FROM f.DATA_WYSTAWIENIA), extract(MONTH FROM f.DATA_WYSTAWIENIA), k.ID_KONTRAHENTA, CASE WHEN k.CZY_FIRMA = '1' THEN k.NAZWA ELSE CONCAT (k.IMIE, CONCAT(' ', k.NAZWISKO)) END
    ORDER BY ROK DESC, MIESIAC DESC;

CREATE VIEW PRZYCHODY_ZESTAWIENIE
AS SELECT
  extract(YEAR FROM f.DATA_WYSTAWIENIA) ROK,
  extract(MONTH FROM f.DATA_WYSTAWIENIA) MIESIAC,
  f.SPOSOB_ZAPLATY SPOSOB_PLATNOSCI,
  COUNT(f.ID_FAKTURY) LICZBA_FAKTUR,
  SUM(f.NETTO) SUMA_NETTO
  FROM FAKTURY f
  WHERE f.CZY_WYCHODZACA = '0'
  group by extract(YEAR FROM f.DATA_WYSTAWIENIA), extract(MONTH FROM f.DATA_WYSTAWIENIA), f.SPOSOB_ZAPLATY
    ORDER BY ROK DESC, MIESIAC DESC;

CREATE VIEW ROZCHODY_ZESTAWIENIE_PODATKI
AS SELECT
  extract(YEAR FROM f.DATA_WYSTAWIENIA) ROK,
  extract(MONTH FROM f.DATA_WYSTAWIENIA) MIESIAC,
  f.STAWKA_VAT VAT,
  COUNT(f.ID_FAKTURY) LICZBA_FAKTUR,
  SUM(f.VAT) SUMA_PODATKU
  FROM FAKTURY f
  WHERE f.CZY_WYCHODZACA = '1'
  group by extract(YEAR FROM f.DATA_WYSTAWIENIA), extract(MONTH FROM f.DATA_WYSTAWIENIA), f.STAWKA_VAT
  ORDER BY ROK DESC, MIESIAC DESC;

CREATE VIEW ROZCHODY_ZESTAWIENIE_TOWARY
AS SELECT
  extract(YEAR FROM d.DATA) ROK,
  extract(MONTH FROM d.DATA) MIESIAC,
  t.NAZWA TOWAR,
  SUM(dp.ILOSC) DOSTARCZONA_ILOSC,
  j.NAZWA JEDNOSTKA,
  SUM(dp.ILOSC) * dp.CENA_JEDNOSTKOWA KOSZT_DOSTAW
  FROM TOWARY t
  JOIN DOSTAWY_POZYCJE dp ON (dp.ID_TOWARU = t.ID_TOWARU)
  JOIN DOSTAWY d ON (d.ID_DOSTAWY = dp.ID_DOSTAWY)
  JOIN SL_JEDNOSTKI j ON (j.ID_JEDNOSTKI = t.ID_JEDNOSTKI)
  group by extract(YEAR FROM d.DATA), extract(MONTH FROM d.DATA), t.NAZWA, j.NAZWA, dp.CENA_JEDNOSTKOWA
  ORDER BY ROK DESC, MIESIAC DESC;

CREATE INDEX DANIA_SKLADNIKI_T_INDEX ON DANIA_SKLADNIKI (ID_TOWARU ASC);

CREATE INDEX DOSTAWY_DOSTAWCY_INDEX ON DOSTAWY (ID_DOSTAWCY ASC);

CREATE INDEX DOSTAWY_POZYCJE_T_INDEX ON DOSTAWY_POZYCJE (ID_TOWARU ASC);

CREATE INDEX FAKTURY_NABYWCY_INDEX ON FAKTURY (ID_NABYWCY ASC);

CREATE INDEX FAKTURY_SPRZEDAWCY_INDEX ON FAKTURY (ID_SPRZEDAWCY ASC);

CREATE INDEX KONTRAHENCI_BANK_INDEX ON KONTRAHENCI (ID_BANKU ASC);

CREATE INDEX TOWARY_JEDNOSTKI_INDEX ON TOWARY (ID_JEDNOSTKI ASC);

CREATE INDEX TOWARY_KATEGORIE_INDEX ON TOWARY (ID_KATEGORII ASC);

CREATE INDEX ZAMOWIENIA_KLIENCI_INDEX ON ZAMOWIENIA (ID_KLIENTA ASC);

CREATE INDEX ZAMOWIENIA_STATUSY_INDEX ON ZAMOWIENIA (STATUS ASC);

CREATE INDEX ZAMOWIENIA_POZYCJE_D_INDEX ON ZAMOWIENIA_POZYCJE (ID_DANIA ASC);

ALTER TABLE KONTRAHENCI
ADD CONSTRAINT KONTRAHENCI_NIP_UK UNIQUE 
(
  NIP 
)
ENABLE;

ALTER TABLE DANIA_SKLADNIKI
ADD CONSTRAINT DANIA_SKLADNIKI_DANIA_FK FOREIGN KEY
(
  ID_DANIA 
)
REFERENCES DANIA
(
  ID_DANIA 
)
ON DELETE CASCADE ENABLE;

ALTER TABLE DANIA_SKLADNIKI
ADD CONSTRAINT DANIA_SKLADNIKI_TOWARY_FK FOREIGN KEY
(
  ID_TOWARU 
)
REFERENCES TOWARY
(
  ID_TOWARU 
)
ON DELETE CASCADE ENABLE;

ALTER TABLE DOSTAWY
ADD CONSTRAINT DOSTAWY_DOSTAWCY_FK FOREIGN KEY
(
  ID_DOSTAWCY 
)
REFERENCES KONTRAHENCI
(
  ID_KONTRAHENTA 
)
ENABLE;

ALTER TABLE DOSTAWY_POZYCJE
ADD CONSTRAINT DOSTAWY_POZYCJE_DOSTAWY_FK FOREIGN KEY
(
  ID_DOSTAWY 
)
REFERENCES DOSTAWY
(
  ID_DOSTAWY 
)
ON DELETE CASCADE ENABLE;

ALTER TABLE DOSTAWY_POZYCJE
ADD CONSTRAINT DOSTAWY_POZYCJE_TOWARY_FK FOREIGN KEY
(
  ID_TOWARU 
)
REFERENCES TOWARY
(
  ID_TOWARU 
)
ON DELETE CASCADE ENABLE;

ALTER TABLE FAKTURY
ADD CONSTRAINT FAKTURY_NABYWCY_FK FOREIGN KEY
(
  ID_NABYWCY 
)
REFERENCES KONTRAHENCI
(
  ID_KONTRAHENTA 
)
ENABLE;

ALTER TABLE FAKTURY
ADD CONSTRAINT FAKTURY_SPRZEDAWCY_FK FOREIGN KEY
(
  ID_SPRZEDAWCY 
)
REFERENCES KONTRAHENCI
(
  ID_KONTRAHENTA 
)
ENABLE;

ALTER TABLE FAKTURY_POZYCJE
ADD CONSTRAINT FAKTURY_POZYCJE_F_FK FOREIGN KEY
(
  ID_FAKTURY 
)
REFERENCES FAKTURY
(
  ID_FAKTURY 
)
ENABLE;

ALTER TABLE FAKTURY_POZYCJE
ADD CONSTRAINT FAKTURY_POZYCJE_J_FK FOREIGN KEY
(
  ID_JEDNOSTKI 
)
REFERENCES SL_JEDNOSTKI
(
  ID_JEDNOSTKI 
)
ENABLE;

ALTER TABLE KONTRAHENCI
ADD CONSTRAINT KONTRAHENCI_BANK_FK FOREIGN KEY
(
  ID_BANKU 
)
REFERENCES SL_BANKI
(
  ID_BANKU 
)
ENABLE;

ALTER TABLE TOWARY
ADD CONSTRAINT TOWARY_JEDNOSTKI_FK FOREIGN KEY
(
  ID_JEDNOSTKI 
)
REFERENCES SL_JEDNOSTKI
(
  ID_JEDNOSTKI 
)
ENABLE;

ALTER TABLE TOWARY
ADD CONSTRAINT TOWARY_KATEGORIE_FK FOREIGN KEY
(
  ID_KATEGORII 
)
REFERENCES SL_KATEGORIE_PODATKOWE
(
  ID_KATEGORII 
)
ENABLE;

ALTER TABLE ZAMOWIENIA
ADD CONSTRAINT ZAMOWIENIA_KLIENCI_FK FOREIGN KEY
(
  ID_KLIENTA 
)
REFERENCES KONTRAHENCI
(
  ID_KONTRAHENTA 
)
ENABLE;

ALTER TABLE ZAMOWIENIA
ADD CONSTRAINT ZAMOWIENIA_STATUS_FK FOREIGN KEY
(
  STATUS 
)
REFERENCES SL_STATUSY_ZAMOWIEN
(
  ID_STATUSU 
)
ENABLE;

ALTER TABLE ZAMOWIENIA_POZYCJE
ADD CONSTRAINT ZAMOWIENIA_POZYCJE_DANIA_FK FOREIGN KEY
(
  ID_DANIA 
)
REFERENCES DANIA
(
  ID_DANIA 
)
ON DELETE CASCADE ENABLE;

ALTER TABLE ZAMOWIENIA_POZYCJE
ADD CONSTRAINT ZAMOWIENIA_POZYCJE_FK FOREIGN KEY
(
  ID_ZAMOWIENIA 
)
REFERENCES ZAMOWIENIA
(
  ID_ZAMOWIENIA 
)
ON DELETE CASCADE ENABLE;

ALTER TABLE FAKTURY
ADD CONSTRAINT FAKTURY_PARTIE_CHK CHECK 
(ID_NABYWCY != ID_SPRZEDAWCY)
ENABLE;

ALTER TABLE FAKTURY
ADD CONSTRAINT FAKTURY_POWIAZANA_FIRMA_CHK CHECK 
(ID_NABYWCY = 1 OR ID_SPRZEDAWCY = 1)
ENABLE;

ALTER TABLE KONTRAHENCI
ADD CONSTRAINT KONTRAHENCI_CZY_FIRMA_CHK CHECK 
(CZY_FIRMA IN ('0', '1'))
ENABLE;

COMMENT ON TABLE DANIA IS 'Zawiera dania z menu wraz z obecna dostepnoscia i cena.';

COMMENT ON TABLE DANIA_SKLADNIKI IS 'Zawiera przyporzadkowania uzywanych skladnikow do dan.';

COMMENT ON TABLE DOSTAWY IS 'Zawiera odebrane dostawy.';

COMMENT ON TABLE DOSTAWY_POZYCJE IS 'Zawiera dostarczone towary z ich iloscia, cena i data waznosci.';

COMMENT ON TABLE FAKTURY IS 'Zawiera szczegolowe dane faktur, zarowno wystawione firmie jak i przez firme. Jedno z ID_NABYWCY, ID_SPRZEDAWCY powinno wskazywac na firme korzystajaca z systemu, czyli powinno byc rowne 1.';

COMMENT ON TABLE FAKTURY_POZYCJE IS 'Zawiera pojedyncze pozycje na fakturze. Sumy wartosci netto vat i brutto pozycji sa zapisywane na fakturze.';

COMMENT ON TABLE KONTRAHENCI IS 'Zawiera dane kontrahentow, ktorzy moga byc osoba fizyczna i firma (koniecznie pierwszy rekord musi reprezentowac firme korzystajaca z systemu, ID_KONTRAHENTA musi byc rowne 1).';

COMMENT ON TABLE SL_BANKI IS 'Zawiera informacje o bankach uzywanych przez kontrahentow.';

COMMENT ON TABLE SL_JEDNOSTKI IS 'Tabela slownikowa z dostepnymi jednostkami, w ktorych wyrazone moga byc produkty.';

COMMENT ON TABLE SL_KATEGORIE_PODATKOWE IS 'Tabela slownikowa z kategoriami produktow spozywczych.';

COMMENT ON TABLE SL_STATUSY_ZAMOWIEN IS 'Zawiera wszystkie statusy, w ktorych moga byc zamowienia.';

COMMENT ON TABLE TOWARY IS 'Zawiera skladowane przez firme towary wraz z ich aktualnym stanem na magazynie.';

COMMENT ON TABLE ZAMOWIENIA IS 'Zawiera zamowienia zlozone przez klientow.';

COMMENT ON TABLE ZAMOWIENIA_POZYCJE IS 'Zawiera zamowione przez klientow dania, wraz z iloscia w sztukach.';

COMMENT ON COLUMN DANIA.DOSTEPNOSC IS 'Ile sztuk danego dania mozna obecnie wytworzyc z towarow na magazynie.';

COMMENT ON COLUMN FAKTURY.NETTO IS 'Suma netto pozycji faktury.';

COMMENT ON COLUMN FAKTURY.VAT IS 'Suma VAT pozycji faktury.';

COMMENT ON COLUMN FAKTURY.BRUTTO IS 'Suma brutto pozycji faktury.';

COMMENT ON COLUMN FAKTURY.CZY_WYCHODZACA IS 'Ma wartosc ''1'' jesli firma musi za nia zaplacic lub ''0'' jesli ktos za nia zaplaci firmie''.';

CREATE TRIGGER TR_USUNIETE_DANIA 
    AFTER DELETE ON dania
    FOR EACH ROW
-- wyzwalacz usuwajacy zamowienia usunietych dan
DECLARE
    -- kursor iterujacy po zamowieniach
    CURSOR c_zamowienia IS
    SELECT z.status
    FROM zamowienia z INNER JOIN zamowienia_pozycje zp
    ON z.id_zamowienia = zp.id_zamowienia
    WHERE zp.id_dania = :old.id_dania;

    row_zamowienia c_zamowienia%ROWTYPE;
BEGIN
    OPEN c_zamowienia;

    LOOP
    -- petla przechodzaca po kolejnych zamowieniach
    FETCH c_zamowienia INTO row_zamowienia;
    EXIT WHEN c_zamowienia%NOTFOUND;

    -- ustawianie statusu na 'odwoany automatycznie'
    row_zamowienia.status := 3;
    END LOOP;

    CLOSE c_zamowienia;
END;
/

CREATE TRIGGER TR_ZMIENIONE_TOWARY 
    AFTER INSERT OR UPDATE OR DELETE ON towary
-- wyzwalacz aktualizujacy dostepnosc dan po zmianie ilosci towarow
DECLARE
    -- kursor iterujacy po daniach dotknietych zmiana
    CURSOR c_dania IS
    SELECT d.id_dania, d.dostepnosc
    FROM dania d;

    row_dania c_dania%ROWTYPE;
BEGIN
    OPEN c_dania;    
    LOOP 
    FETCH c_dania INTO row_dania;
    EXIT WHEN c_dania%NOTFOUND;
     -- obliczamy maksymalna ilosc dan jaka mozemy wyprodukowac oraz ustawiamy ja jako dostepnosc
    SELECT MIN(FLOOR(t.ilosc / dk.ilosc)) INTO row_dania.dostepnosc
    FROM towary t
    INNER JOIN dania_skladniki dk
    ON dk.id_towaru = t.id_towaru
    WHERE dk.id_dania = row_dania.id_dania;
    END LOOP;
    CLOSE c_dania;
END;
/

CREATE TRIGGER TR_ZMIENIONY_SKLAD_DAN 
    AFTER INSERT OR UPDATE OR DELETE ON dania_skladniki
-- wyzwalacz aktualizujacy dostepnosc dan po zmianie skladnikow potrzebnych do wyprodukowania dan
DECLARE
    -- kursor iterujacy po daniach dotknietych zmiana
    CURSOR c_dania IS
    SELECT d.id_dania, d.dostepnosc
    FROM dania d;

    row_dania c_dania%ROWTYPE;
BEGIN
    OPEN c_dania;    
    LOOP 
    FETCH c_dania INTO row_dania;
    EXIT WHEN c_dania%NOTFOUND;
     -- obliczamy maksymalna ilosc dan jaka mozemy wyprodukowac oraz ustawiamy ja jako dostepnosc
    SELECT MIN(FLOOR(t.ilosc / dk.ilosc)) INTO row_dania.dostepnosc
    FROM towary t
    INNER JOIN dania_skladniki dk
    ON dk.id_towaru = t.id_towaru
    WHERE dk.id_dania = row_dania.id_dania;
    END LOOP;
    CLOSE c_dania;
END;
/

create or replace TRIGGER TR_Zmiania_faktury
    AFTER INSERT OR UPDATE OR DELETE ON faktury_pozycje
    FOR EACH ROW
-- wyzwalacz aktualizujacy faktury po zmianie w pozycjach
DECLARE
    old_netto faktury.netto%TYPE;
    old_vat faktury.vat%TYPE;
    old_brutto faktury.brutto%TYPE;
    new_netto faktury.netto%TYPE;
    new_vat faktury.vat%TYPE;
    new_brutto faktury.brutto%TYPE;
BEGIN
    -- przypisanie wartosci do zmiennych
    old_netto := NVL(:old.netto, 0);
    old_vat := NVL(:old.vat, 0);
    old_brutto := NVL(:old.brutto, 0);
    new_netto := NVL(:new.netto, 0);
    new_vat := NVL(:new.vat, 0);
    new_brutto := NVL(:new.brutto, 0);

    UPDATE faktury f
    SET
    -- aktualizowanie o roznice wartosci netto, vat i brutto zmienionej pozycji
        f.netto = f.netto - old_netto + new_netto,
        f.vat = f.vat - old_vat + new_vat,
        f.brutto = f.brutto - old_brutto + new_brutto
    WHERE f.id_faktury = :old.id_faktury
    OR f.id_faktury = :new.id_faktury;
END;
/
